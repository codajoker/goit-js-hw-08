{"version":3,"sources":["../debounce.js","../throttle.js","js/03-feedback.js"],"names":["delay","noTrailing","callback","debounceMode","timeoutID","cancelled","lastExec","clearExistingTimeout","clearTimeout","wrapper","arguments_","self","elapsed","Date","now","exec","apply","undefined","setTimeout","clear","cancel","atBegin","throttle","refs","form","document","querySelector","email","coment","FORM_KEY","formObject","message","handleSubmit","e","preventDefault","console","log","target","elements","value","reset","localStorage","removeItem","handleInputChange","name","setItem","JSON","stringify","initForm","formFields","parse","getItem","addEventListener","window"],"mappings":";AAsBC,aCJc,SAAA,EAAUA,EAAOC,EAAYC,EAAUC,GAMjDC,IAAAA,EACAC,GAAY,EAGZC,EAAW,EAGNC,SAAAA,IACJH,GACHI,aAAaJ,GAsBNK,SAAAA,IAAuB,IAAA,IAAA,EAAA,UAAA,OAAZC,EAAY,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAZA,EAAY,GAAA,UAAA,GAC3BC,IAAAA,EAAO,KACPC,EAAUC,KAAKC,MAAQR,EAOlBS,SAAAA,IACRT,EAAWO,KAAKC,MAChBZ,EAASc,MAAML,EAAMD,GAPlBL,IAkBAF,IAAiBC,GAKpBW,IAGDR,SAEqBU,IAAjBd,GAA8BS,EAAUZ,EAK3Ce,KACyB,IAAfd,IAYVG,EAAYc,WACXf,EAjCOgB,WACRf,OAAYa,GAgCYF,OACNE,IAAjBd,EAA6BH,EAAQY,EAAUZ,KAQ3CS,MAvEmB,kBAAfR,IACVE,EAAeD,EACfA,EAAWD,EACXA,OAAagB,GAiEdR,EAAQW,OA1ECA,WACRb,IACAF,GAAY,GA2ENI,EDjGO,SAAA,EAAUT,EAAOqB,EAASnB,GACjCA,YAAae,IAAbf,EACJoB,EAAStB,EAAOqB,GAAS,GACzBC,EAAStB,EAAOE,GAAsB,IAAZmB,GAC7B,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAAA,QAAA,SAAA;;AEyED,aA/FA,IAAA,EAAA,QAAA,qBACA,MAAME,EAAO,CACXC,KAAMC,SAASC,cAAc,kBAC7BC,MAAOF,SAASC,cAAc,SAC9BE,OAAQH,SAASC,cAAc,aAE3BG,EAAW,sBACXC,EAAa,CACjBH,MAAO,GACPI,QAAS,IAIX,SAASC,EAAaC,GACpBA,EAAEC,iBACFC,QAAQC,cAAcH,EAAEI,OAAOC,SAASX,MAAMY,SAC9CJ,QAAQC,gBAAgBH,EAAEI,OAAOC,SAASP,QAAQQ,SAElDN,EAAEI,OAAOG,QAETC,aAAaC,WAAWb,GAE1B,SAASc,EAAkBV,GACzBH,EAAWG,EAAEI,OAAOO,MAAQX,EAAEI,OAAOE,MAErCE,aAAaI,QAAQhB,EAAUiB,KAAKC,UAAUjB,IAGhD,SAASkB,IACDC,MAAAA,EAAaH,KAAKI,MAAMT,aAAaU,QAAQtB,IAC/CoB,IACFnB,EAAWH,MAAQsB,EAAWtB,MAC9BG,EAAWC,QAAUkB,EAAWlB,QAChCR,EAAKI,MAAMY,MAAQU,EAAWtB,MAC9BJ,EAAKK,OAAOW,MAAQU,EAAWlB,SAvBnCR,EAAKC,KAAK4B,iBAAiB,SAAUpB,GACrCT,EAAKC,KAAK4B,iBAAiB,SAAS,EAAS,EAAA,UAAA,IAAKT,IAelDU,OAAOD,iBAAiB,mBAAoBJ","file":"03-feedback.497091d6.js","sourceRoot":"../src","sourcesContent":["/* eslint-disable no-undefined */\n\nimport throttle from './throttle';\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\nexport default function (delay, atBegin, callback) {\n\treturn callback === undefined\n\t\t? throttle(delay, atBegin, false)\n\t\t: throttle(delay, callback, atBegin !== false);\n}\n","/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nexport default function (delay, noTrailing, callback, debounceMode) {\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel() {\n\t\tclearExistingTimeout();\n\t\tcancelled = true;\n\t}\n\n\t// `noTrailing` defaults to falsy.\n\tif (typeof noTrailing !== 'boolean') {\n\t\tdebounceMode = callback;\n\t\tcallback = noTrailing;\n\t\tnoTrailing = undefined;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\t/*\n\t\t\t * In throttle mode, if `delay` time has been exceeded, execute\n\t\t\t * `callback`.\n\t\t\t */\n\t\t\texec();\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n","import { throttle } from 'throttle-debounce';\nconst refs = {\n  form: document.querySelector('.feedback-form'),\n  email: document.querySelector('input'),\n  coment: document.querySelector('textarea'),\n};\nconst FORM_KEY = 'feedback-form-state';\nconst formObject = {\n  email: '',\n  message: '',\n};\nrefs.form.addEventListener('submit', handleSubmit);\nrefs.form.addEventListener('input', throttle(500, handleInputChange));\nfunction handleSubmit(e) {\n  e.preventDefault();\n  console.log(`email: ${e.target.elements.email.value}`);\n  console.log(`message: ${e.target.elements.message.value}`);\n\n  e.target.reset();\n\n  localStorage.removeItem(FORM_KEY);\n}\nfunction handleInputChange(e) {\n  formObject[e.target.name] = e.target.value;\n\n  localStorage.setItem(FORM_KEY, JSON.stringify(formObject));\n}\nwindow.addEventListener('DOMContentLoaded', initForm);\nfunction initForm() {\n  const formFields = JSON.parse(localStorage.getItem(FORM_KEY));\n  if (formFields) {\n    formObject.email = formFields.email;\n    formObject.message = formFields.message;\n    refs.email.value = formFields.email;\n    refs.coment.value = formFields.message;\n  }\n}\n// const formData = {};\n// initForm();\n\n// refs.form.addEventListener('submit', e => {\n//   e.preventDefault();\n//   const formData = new FormData(refs.form);\n//   formData.forEach((email, message) => console.log(email, message));\n//   e.target.reset();\n//   localStorage.removeItem(FORM_KEY);\n// });\n// refs.form.addEventListener(\n//   'input',\n//   throttle(500, e => {\n//     let persistedFilters = localStorage.getItem(FORM_KEY);\n//     persistedFilters = persistedFilters ? JSON.parse(persistedFilters) : {};\n//     persistedFilters[e.target.name] = e.target.value;\n//     localStorage.setItem(FORM_KEY, JSON.stringify(persistedFilters));\n//   }),\n// );\n\n// function initForm() {\n//   let persistedFilters = localStorage.getItem(FORM_KEY);\n//   if (persistedFilters) {\n//     persistedFilters = JSON.parse(persistedFilters);\n//     Object.entries(persistedFilters).forEach(([name, value]) => {\n//       refs.form.elements[name].value = value;\n//     });\n//   }\n// }\n// refs.form.addEventListener('input', throttle(500, onFormChange));\n// popularInput();\n\n// function onSubmitForm(e) {\n//   e.preventDefault();\n//   if (JSON.parse(localStorage.getItem(FORM_KEY)) !== null) {\n//     console.log(`email : ${JSON.parse(localStorage.getItem(FORM_KEY)).email}`);\n//     console.log(`message : ${JSON.parse(localStorage.getItem(FORM_KEY)).message}`);\n//   }\n\n//   e.target.reset();\n//   localStorage.removeItem(FORM_KEY);\n// }\n\n// function onFormChange(e) {\n//   formData[e.target.name] = e.target.value;\n//   localStorage.setItem(FORM_KEY, JSON.stringify(formData));\n// }\n\n// function popularInput() {\n//   const savedFormKey = localStorage.getItem(FORM_KEY);\n//   const parsedFormKey = JSON.parse(savedFormKey);\n//   if (parsedFormKey === null) return;\n//   if (parsedFormKey.message) {\n//     refs.coment.value = parsedFormKey.message;\n//   }\n//   if (parsedFormKey.email) {\n//     refs.email.value = parsedFormKey.email;\n//   }\n// }\n"]}