{"version":3,"sources":["../debounce.js","../throttle.js","js/03-feedback.js"],"names":["delay","noTrailing","callback","debounceMode","timeoutID","cancelled","lastExec","clearExistingTimeout","clearTimeout","wrapper","arguments_","self","elapsed","Date","now","exec","apply","undefined","setTimeout","clear","cancel","atBegin","throttle","refs","form","document","querySelector","email","coment","FORM_KEY","initForm","persistedFilters","localStorage","getItem","JSON","parse","Object","entries","forEach","name","value","elements","addEventListener","e","preventDefault","FormData","message","console","log","target","reset","removeItem","setItem","stringify"],"mappings":";AAsBC,aCJc,SAAA,EAAUA,EAAOC,EAAYC,EAAUC,GAMjDC,IAAAA,EACAC,GAAY,EAGZC,EAAW,EAGNC,SAAAA,IACJH,GACHI,aAAaJ,GAsBNK,SAAAA,IAAuB,IAAA,IAAA,EAAA,UAAA,OAAZC,EAAY,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAZA,EAAY,GAAA,UAAA,GAC3BC,IAAAA,EAAO,KACPC,EAAUC,KAAKC,MAAQR,EAOlBS,SAAAA,IACRT,EAAWO,KAAKC,MAChBZ,EAASc,MAAML,EAAMD,GAPlBL,IAkBAF,IAAiBC,GAKpBW,IAGDR,SAEqBU,IAAjBd,GAA8BS,EAAUZ,EAK3Ce,KACyB,IAAfd,IAYVG,EAAYc,WACXf,EAjCOgB,WACRf,OAAYa,GAgCYF,OACNE,IAAjBd,EAA6BH,EAAQY,EAAUZ,KAQ3CS,MAvEmB,kBAAfR,IACVE,EAAeD,EACfA,EAAWD,EACXA,OAAagB,GAiEdR,EAAQW,OA1ECA,WACRb,IACAF,GAAY,GA2ENI,EDjGO,SAAA,EAAUT,EAAOqB,EAASnB,GACjCA,YAAae,IAAbf,EACJoB,EAAStB,EAAOqB,GAAS,GACzBC,EAAStB,EAAOE,GAAsB,IAAZmB,GAC7B,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAAA,QAAA,SAAA;;AE2CD,aAjEA,IAAA,EAAA,QAAA,qBACA,MAAME,EAAO,CACXC,KAAMC,SAASC,cAAc,kBAC7BC,MAAOF,SAASC,cAAc,SAC9BE,OAAQH,SAASC,cAAc,aAE3BG,EAAW,sBAqBjB,SAASC,IACHC,IAAAA,EAAmBC,aAAaC,QAAQJ,GACxCE,IACFA,EAAmBG,KAAKC,MAAMJ,GAC9BK,OAAOC,QAAQN,GAAkBO,QAAQ,EAAEC,EAAMC,MAC/CjB,EAAKC,KAAKiB,SAASF,GAAMC,MAAQA,KAxBvCV,IAEAP,EAAKC,KAAKkB,iBAAiB,SAAUC,IACnCA,EAAEC,iBACe,IAAIC,SAAStB,EAAKC,MAC1Bc,QAAQ,CAACX,EAAOmB,IAAYC,QAAQC,IAAIrB,EAAOmB,IACxDH,EAAEM,OAAOC,QACTlB,aAAamB,WAAWtB,KAE1BN,EAAKC,KAAKkB,iBACR,SACA,EAAS,EAAA,UAAA,IAAKC,IACRZ,IAAAA,EAAmBC,aAAaC,QAAQJ,IAC5CE,EAAmBA,EAAmBG,KAAKC,MAAMJ,GAAoB,IACpDY,EAAEM,OAAOV,MAAQI,EAAEM,OAAOT,MAC3CR,aAAaoB,QAAQvB,EAAUK,KAAKmB,UAAUtB","file":"03-feedback.8311d366.js","sourceRoot":"../src","sourcesContent":["/* eslint-disable no-undefined */\n\nimport throttle from './throttle';\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\nexport default function (delay, atBegin, callback) {\n\treturn callback === undefined\n\t\t? throttle(delay, atBegin, false)\n\t\t: throttle(delay, callback, atBegin !== false);\n}\n","/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nexport default function (delay, noTrailing, callback, debounceMode) {\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel() {\n\t\tclearExistingTimeout();\n\t\tcancelled = true;\n\t}\n\n\t// `noTrailing` defaults to falsy.\n\tif (typeof noTrailing !== 'boolean') {\n\t\tdebounceMode = callback;\n\t\tcallback = noTrailing;\n\t\tnoTrailing = undefined;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\t/*\n\t\t\t * In throttle mode, if `delay` time has been exceeded, execute\n\t\t\t * `callback`.\n\t\t\t */\n\t\t\texec();\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n","import { throttle } from 'throttle-debounce';\nconst refs = {\n  form: document.querySelector('.feedback-form'),\n  email: document.querySelector('input'),\n  coment: document.querySelector('textarea'),\n};\nconst FORM_KEY = 'feedback-form-state';\n// const formData = {};\ninitForm();\n\nrefs.form.addEventListener('submit', e => {\n  e.preventDefault();\n  const formData = new FormData(refs.form);\n  formData.forEach((email, message) => console.log(email, message));\n  e.target.reset();\n  localStorage.removeItem(FORM_KEY);\n});\nrefs.form.addEventListener(\n  'input',\n  throttle(500, e => {\n    let persistedFilters = localStorage.getItem(FORM_KEY);\n    persistedFilters = persistedFilters ? JSON.parse(persistedFilters) : {};\n    persistedFilters[e.target.name] = e.target.value;\n    localStorage.setItem(FORM_KEY, JSON.stringify(persistedFilters));\n  }),\n);\n\nfunction initForm() {\n  let persistedFilters = localStorage.getItem(FORM_KEY);\n  if (persistedFilters) {\n    persistedFilters = JSON.parse(persistedFilters);\n    Object.entries(persistedFilters).forEach(([name, value]) => {\n      refs.form.elements[name].value = value;\n    });\n  }\n}\n// refs.form.addEventListener('input', throttle(500, onFormChange));\n// popularInput();\n\n// function onSubmitForm(e) {\n//   e.preventDefault();\n//   if (JSON.parse(localStorage.getItem(FORM_KEY)) !== null) {\n//     console.log(`email : ${JSON.parse(localStorage.getItem(FORM_KEY)).email}`);\n//     console.log(`message : ${JSON.parse(localStorage.getItem(FORM_KEY)).message}`);\n//   }\n\n//   e.target.reset();\n//   localStorage.removeItem(FORM_KEY);\n// }\n\n// function onFormChange(e) {\n//   formData[e.target.name] = e.target.value;\n//   localStorage.setItem(FORM_KEY, JSON.stringify(formData));\n// }\n\n// function popularInput() {\n//   const savedFormKey = localStorage.getItem(FORM_KEY);\n//   const parsedFormKey = JSON.parse(savedFormKey);\n//   if (parsedFormKey === null) return;\n//   if (parsedFormKey.message) {\n//     refs.coment.value = parsedFormKey.message;\n//   }\n//   if (parsedFormKey.email) {\n//     refs.email.value = parsedFormKey.email;\n//   }\n// }\n"]}